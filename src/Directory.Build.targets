<Project>

  <Target Name="GetProjectSrc">
    <ItemGroup>
      <!--
        Files that may need the 'constraint' token fixed before they can be assembled. They were
        decompiled with a 3.1 ildasm not compatible with 5.0 ilasm. In some cases the fix is not
        necessary for a given IL filename in a certain TFM, but is necessary for a file with the
        same name in a different TFM. The patch doesn't take a particularly long time, so prefer
        keeping this list simple.
      -->
      <TargetingPackSrcRequiringConstraintPatch
        Include="
          $(MSBuildProjectDirectory)\**\Microsoft.AspNetCore.Components.il;
          $(MSBuildProjectDirectory)\**\Microsoft.AspNetCore.Mvc.Cors.il;
          $(MSBuildProjectDirectory)\**\Microsoft.AspNetCore.Routing.il;
          $(MSBuildProjectDirectory)\**\netstandard.il;
          $(MSBuildProjectDirectory)\**\presentationframework.*.il;
          $(MSBuildProjectDirectory)\**\PresentationFramework.*.il;
          $(MSBuildProjectDirectory)\**\PresentationFramework.il;
          $(MSBuildProjectDirectory)\**\System.Activities.Presentation.il;
          $(MSBuildProjectDirectory)\**\System.ComponentModel.Composition.il;
          $(MSBuildProjectDirectory)\**\System.Data.Common.il;
          $(MSBuildProjectDirectory)\**\System.Data.Entity.il;
          $(MSBuildProjectDirectory)\**\System.Data.il;
          $(MSBuildProjectDirectory)\**\System.Design.il;
          $(MSBuildProjectDirectory)\**\System.Reflection.Metadata.il;
          $(MSBuildProjectDirectory)\**\System.Web.il;
          $(MSBuildProjectDirectory)\**\System.Xml.il;
          $(MSBuildProjectDirectory)\**\System.XML.il;
          $(MSBuildProjectDirectory)\**\WindowsFormsIntegration.il" />

      <!-- Find all IL. Leave out IL that needs to be patched before being built. -->
      <TargetingPackSrc
        Include="$(MSBuildProjectDirectory)\**\*.il"
        Exclude="@(TargetingPackSrcRequiringConstraintPatch)" />
      <TargetingPackSrc
        RelativeOutputAssemblyFile="%(RecursiveDir)%(Filename).dll" />

      <PotentialCompileSrc Include="**\*.cs" />

      <NuGetGeneratedMetadataFile Include="
        .signature.p7s;
        _rels\**;
        [Content_Types].xml;
        " />

      <StructureFile
        Include="**\*.*"
        Exclude="
          @(TargetingPackSrc);
          @(TargetingPackSrcRequiringConstraintPatch);
          @(PotentialCompileSrc);
          **\*.csproj;
          @(NuGetGeneratedMetadataFile);
          "/>

      <StaticAssetFile
        Include="@(StructureFile)"
        Destination="$(TFMPackTempOutputDir)%(RecursiveDir)%(Filename)%(Extension)" />
    </ItemGroup>
  </Target>

  <Target Name="CopyBuildOutputToTempOutput"
          Condition="'$(TargetFramework)' != ''"
          AfterTargets="CopyFilesToOutputDirectory">
    <Error
      Condition="@(Compile->Count()) != 1"
      Text="Number of Compile items != 1. We need just one, to determine the path of the resulting DLL in the package including ref/lib and TFM." />

    <ItemGroup>
      <FullCompileDir Include="$([System.IO.Directory]::GetParent('%(Compile.Identity)'))" />
      <RelativeCompileDir Include="$([MSBuild]::MakeRelative('$(MSBuildProjectDirectory)\', '%(FullCompileDir.Identity)'))" />
    </ItemGroup>

    <Copy
      SourceFiles="$(TargetPath)"
      DestinationFiles="$([MSBuild]::NormalizePath(
        '$(TFMPackTempOutputDir)',
        '%(RelativeCompileDir.Identity)',
        '$(TargetFileName)'))" />
  </Target>

  <Target Name="CopyStaticAssetsToOutput"
          BeforeTargets="Pack;GenerateNuspec"
          DependsOnTargets="GetProjectSrc">
    <!-- Ensure TFMPackTempOutputDir defined, to avoid globbing entire machine... -->
    <Error Condition="'$(TFMPackTempOutputDir)' == ''" Text="TFMPackTempOutputDir not defined" />

    <Copy
      SourceFiles="@(StaticAssetFile)"
      DestinationFiles="@(StaticAssetFile -> '%(Destination)')" />
  </Target>

  <Target Name="FindNuspecFileItem">
    <ItemGroup>
      <NuspecFile Include="*.nuspec" />
    </ItemGroup>

    <Error Condition="@(NuspecFile->Count()) != 1" Text="Expected exactly one nuspec file." />
  </Target>

  <!--
    Instead of using the nuspec inside the directory, use the one that we copied to a temp
    directory. Normally this would be done by setting the NuspecFile property statically. However,
    in this case, the project file already sets it to some other value, which takes priority over
    Directory.Build.props. We also don't want to modify the project files too much, for branch
    merging and general noise reduction.

    This target is also a nice place to enforce that we do actually have a nuspec.
  -->
  <Target Name="SetManualPackTaskInputs"
          Condition="'$(PackNuspecInPlace)' != 'true'"
          DependsOnTargets="FindNuspecFileItem"
          BeforeTargets="_CalculateInputsOutputsForPack;GenerateNuspec">
    <PropertyGroup>
      <NuspecFile>$(TFMPackTempOutputDir)@(NuspecFile)</NuspecFile>
    </PropertyGroup>
  </Target>

  <Target Name="SetManualPackTaskInputsInPlace"
          Condition="'$(PackNuspecInPlace)' == 'true'"
          DependsOnTargets="FindNuspecFileItem"
          BeforeTargets="_CalculateInputsOutputsForPack;GenerateNuspec">
    <PropertyGroup>
      <NuspecFile>@(NuspecFile)</NuspecFile>
    </PropertyGroup>
  </Target>

  <!-- Import SDK and Arcade SDK. Overrides below. -->
  <Import Project="$([MSBuild]::GetPathOfFileAbove(Directory.Build.targets, $(MSBuildThisFileDirectory)..))" />

  <!--
    Disable Arcade util that populates PackTask properties. For these projects, the nuspec already
    contains everything. It's generated when the package is initially deconstructed and tends to be
    unique per package, so there's no benefit to this Arcade util.
  -->
  <Target Name="InitializeStandardNuspecProperties" />

</Project>
