// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
// ------------------------------------------------------------------------------
// Changes to this file must follow the http://aka.ms/api-review process.
// ------------------------------------------------------------------------------
[assembly: System.Runtime.CompilerServices.CompilationRelaxations(8)]
[assembly: System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName = "")]
[assembly: System.Reflection.AssemblyTitle("System.IO.Pipelines")]
[assembly: System.Reflection.AssemblyDescription("System.IO.Pipelines")]
[assembly: System.Reflection.AssemblyConfiguration("")]
[assembly: System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly: System.Reflection.AssemblyProduct("System.IO.Pipelines")]
[assembly: System.Reflection.AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")]
[assembly: System.Reflection.AssemblyTrademark("")]
[assembly: System.Reflection.AssemblyFileVersion("5.0.1.0")]
[assembly: System.Reflection.AssemblyVersion("5.0.1.0")]

// This is a minimal stub for System.IO.Pipelines 5.0.1
// The actual API surface is extensive and should be generated by the tooling

namespace System.IO.Pipelines
{
    public sealed class Pipe
    {
        public Pipe() { }
        public Pipe(PipeOptions options) { }
        public PipeReader Reader { get; }
        public PipeWriter Writer { get; }
        public void Reset() { }
    }

    public abstract class PipeReader
    {
        public abstract void AdvanceTo(System.SequencePosition consumed);
        public abstract void AdvanceTo(System.SequencePosition consumed, System.SequencePosition examined);
        public abstract void CancelPendingRead();
        public abstract void Complete(System.Exception exception = null);
        public abstract System.Threading.Tasks.ValueTask<ReadResult> ReadAsync(System.Threading.CancellationToken cancellationToken = default);
        public abstract bool TryRead(out ReadResult result);
        public virtual System.Threading.Tasks.ValueTask CompleteAsync(System.Exception exception = null) => default;
        public virtual System.IO.Stream AsStream(bool leaveOpen = false) => null;
        public virtual void OnWriterCompleted(System.Action<System.Exception, object> callback, object state) { }
        public static PipeReader Create(System.IO.Stream stream) => null;
        public static PipeReader Create(System.IO.Stream stream, StreamPipeReaderOptions readerOptions) => null;
        public static PipeReader Create(System.ReadOnlySequence<byte> sequence) => null;
    }

    public abstract class PipeWriter
    {
        public abstract void Advance(int bytes);
        public abstract void CancelPendingFlush();
        public abstract void Complete(System.Exception exception = null);
        public abstract System.Threading.Tasks.ValueTask<FlushResult> FlushAsync(System.Threading.CancellationToken cancellationToken = default);
        public abstract System.Memory<byte> GetMemory(int sizeHint = 0);
        public abstract System.Span<byte> GetSpan(int sizeHint = 0);
        public virtual System.Threading.Tasks.ValueTask CompleteAsync(System.Exception exception = null) => default;
        public virtual System.IO.Stream AsStream(bool leaveOpen = false) => null;
        public virtual void OnReaderCompleted(System.Action<System.Exception, object> callback, object state) { }
        public virtual System.Threading.Tasks.ValueTask<FlushResult> WriteAsync(System.ReadOnlyMemory<byte> source, System.Threading.CancellationToken cancellationToken = default) => default;
        public static PipeWriter Create(System.IO.Stream stream) => null;
        public static PipeWriter Create(System.IO.Stream stream, StreamPipeWriterOptions writerOptions) => null;
    }

    public readonly struct ReadResult
    {
        public ReadResult(System.ReadOnlySequence<byte> buffer, bool isCanceled, bool isCompleted) { }
        public System.ReadOnlySequence<byte> Buffer { get; }
        public bool IsCanceled { get; }
        public bool IsCompleted { get; }
    }

    public readonly struct FlushResult
    {
        public FlushResult(bool isCanceled, bool isCompleted) { }
        public bool IsCanceled { get; }
        public bool IsCompleted { get; }
    }

    public class PipeOptions
    {
        public PipeOptions() { }
        public PipeOptions(System.Buffers.MemoryPool<byte> pool = null, PipeScheduler readerScheduler = null, PipeScheduler writerScheduler = null, long pauseWriterThreshold = -1, long resumeWriterThreshold = -1, int minimumSegmentSize = -1, bool useSynchronizationContext = true) { }
        public static PipeOptions Default { get; }
        public System.Buffers.MemoryPool<byte> Pool { get; }
        public PipeScheduler ReaderScheduler { get; }
        public PipeScheduler WriterScheduler { get; }
        public long PauseWriterThreshold { get; }
        public long ResumeWriterThreshold { get; }
        public int MinimumSegmentSize { get; }
        public bool UseSynchronizationContext { get; }
    }

    public abstract class PipeScheduler
    {
        public abstract void Schedule(System.Action<object> action, object state);
        public static PipeScheduler ThreadPool { get; }
        public static PipeScheduler Inline { get; }
    }

    public class StreamPipeReaderOptions
    {
        public StreamPipeReaderOptions() { }
        public StreamPipeReaderOptions(System.Buffers.MemoryPool<byte> pool = null, int bufferSize = -1, int minimumReadSize = -1, bool leaveOpen = false, bool useZeroByteReads = false) { }
        public System.Buffers.MemoryPool<byte> Pool { get; }
        public int BufferSize { get; }
        public int MinimumReadSize { get; }
        public bool LeaveOpen { get; }
        public bool UseZeroByteReads { get; }
    }

    public class StreamPipeWriterOptions
    {
        public StreamPipeWriterOptions() { }
        public StreamPipeWriterOptions(System.Buffers.MemoryPool<byte> pool = null, int minimumBufferSize = -1, bool leaveOpen = false) { }
        public System.Buffers.MemoryPool<byte> Pool { get; }
        public int MinimumBufferSize { get; }
        public bool LeaveOpen { get; }
    }

    public static class PipeReaderExtensions
    {
        public static System.Threading.Tasks.Task CopyToAsync(this PipeReader reader, System.IO.Stream destination, System.Threading.CancellationToken cancellationToken = default) => null;
        public static System.Threading.Tasks.Task CopyToAsync(this PipeReader reader, PipeWriter destination, System.Threading.CancellationToken cancellationToken = default) => null;
    }

    public static class PipeWriterExtensions
    {
        public static System.Threading.Tasks.ValueTask<FlushResult> WriteAsync(this PipeWriter writer, System.ReadOnlyMemory<byte> source, System.Threading.CancellationToken cancellationToken = default) => default;
    }
}