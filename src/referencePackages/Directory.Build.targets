<Project>

  <Import Project="..\..\Directory.Build.targets" />

  <PropertyGroup>
    <!-- Disable RAR from transitively discovering dependencies for references. This is required as we don't copy
         dependencies over into the output directory which means RAR can't resolve them.
         This is also necessary to make P2Ps with same package ids but different versions work. -->
    <_FindDependencies>false</_FindDependencies>

    <CustomizationsPropsPath>$(MSBuildProjectDirectory)\$(CustomizationsPropsFile)</CustomizationsPropsPath>
    <CustomizationsSourcePath>$(MSBuildProjectDirectory)\$(CustomizationsSourceFile)</CustomizationsSourcePath>
  </PropertyGroup>

  <!-- Project references don't need to be copied to the output. That makes the build significantly faster. -->
  <ItemDefinitionGroup>
    <ProjectReference>
      <Private>false</Private>
    </ProjectReference>
  </ItemDefinitionGroup>

  <ItemGroup>
    <Compile Include="ref/$(TargetFramework)/*$(DefaultLanguageSourceExtension)" />
    <Compile Include="lib/$(TargetFramework)/*$(DefaultLanguageSourceExtension)" />

    <!-- Attributes for all Reference Packages -->
    <Compile Include="$(RepoRoot)src\SourceBuildAssemblyMetdata.cs" />

    <!-- Customization extension point -->
    <Compile Include="$(CustomizationsSourcePath)" Condition="Exists('$(CustomizationsSourcePath)')" />
  </ItemGroup>

  <!-- Customization extension point -->
  <Import Project="$(CustomizationsPropsPath)" Condition="Exists('$(CustomizationsPropsPath)')" />

  <PropertyGroup>
    <!-- Avoid transitive framework reference downloads to minimize the number of targeting packs and prebuilts. -->
    <DisableTransitiveFrameworkReferenceDownloads>true</DisableTransitiveFrameworkReferenceDownloads>
    <!-- The SDK already sets the NETStandardImplicitPackageVersion and we don't expect it to change anymore. Hence, we don't encode it here. -->
  </PropertyGroup>

  <!-- Keep in sync with available targeting packs under src/targetPacks/ILsrc. -->
  <ItemGroup>
    <KnownFrameworkReference Update="@(KnownFrameworkReference->WithMetadataValue('Identity', 'Microsoft.NETCore.App'))">
      <TargetingPackVersion Condition="'%(TargetFramework)' == 'netcoreapp3.0'">3.0.0</TargetingPackVersion>
      <TargetingPackVersion Condition="'%(TargetFramework)' == 'netcoreapp3.1'">3.1.0</TargetingPackVersion>
      <TargetingPackVersion Condition="$([System.Text.RegularExpressions.Regex]::IsMatch('%(TargetFramework)', '^net\d+\.0$'))">$([System.Text.RegularExpressions.Regex]::Match('%(TargetFramework)', '\d+').Value).0.0</TargetingPackVersion>
    </KnownFrameworkReference>

    <KnownFrameworkReference Update="@(KnownFrameworkReference->WithMetadataValue('Identity', 'Microsoft.AspNetCore.App'))">
      <TargetingPackVersion Condition="'%(TargetFramework)' == 'net6.0'">6.0.2</TargetingPackVersion>
    </KnownFrameworkReference>

    <KnownFrameworkReference Update="@(KnownFrameworkReference->WithMetadataValue('Identity', 'NETStandard.Library'))">
      <TargetingPackVersion Condition="'%(TargetFramework)' == 'netstandard2.1'">2.1.0</TargetingPackVersion>
    </KnownFrameworkReference>
  </ItemGroup>

  <!-- Conflict resolution doesn't see P2Ps: https://github.com/dotnet/sdk/issues/2674. -->
  <Target Name="PassProjectReferencesToConflictResolution"
          BeforeTargets="_HandlePackageFileConflicts"
          DependsOnTargets="ResolveProjectReferences">
    <ItemGroup>
      <Reference Include="@(_ResolvedProjectReferencePaths)" />
      <_ResolvedProjectReferencePaths Remove="@(_ResolvedProjectReferencePaths)" />
    </ItemGroup>
  </Target>

  <!-- Filter out conflicting implicit assembly references. -->
  <Target Name="FilterImplicitAssemblyReferences"
          DependsOnTargets="ResolveProjectReferences"
          AfterTargets="ResolveTargetingPackAssets">
    <ItemGroup>
      <Reference Remove="@(Reference->WithMetadataValue('ExternallyResolved', 'true')->WithMetadataValue('Filename', '$(TargetName)'))" />
    </ItemGroup>
  </Target>

  <Target Name="CopyBuildOutputToTempOutput"
          AfterTargets="CopyFilesToOutputDirectory">
    <ItemGroup>
      <CompileWithRelativePath Include="@(Compile)" Condition="!$([System.String]::new('%(Identity)').StartsWith('%(RootDir)'))" />
    </ItemGroup>

    <Error
      Condition="@(CompileWithRelativePath->Count()) != 1"
      Text="Number of Compile items != 1. We need just one, to determine the path of the resulting DLL in the package including ref/lib and TFM." />

    <ItemGroup>
      <FullCompileDir Include="$([System.IO.Directory]::GetParent('%(CompileWithRelativePath.Identity)'))" />
      <RelativeCompileDir Include="$([MSBuild]::MakeRelative('$(MSBuildProjectDirectory)\', '%(FullCompileDir.Identity)'))" />
    </ItemGroup>

    <Copy
      SourceFiles="$(TargetPath)"
      DestinationFiles="$([MSBuild]::NormalizePath(
        '$(TFMPackTempOutputDir)',
        '%(RelativeCompileDir.Identity)',
        '$(TargetFileName)'))" />
  </Target>

</Project>
