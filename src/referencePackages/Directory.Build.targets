<Project>

  <Import Project="..\..\Directory.Build.targets" />

  <!-- netstandard2.0's targeting pack uses the old package reference model which doesn't support using a local layout.
       Therefore disable the package reference download via DisableImplicitFrameworkReferences and manually import the
       packages' targets file to receive the references. -->
  <PropertyGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <NETStandardLibraryArtifactsDir>$(ArtifactsBinDir)NETStandard.Library.2.0.3\pack\</NETStandardLibraryArtifactsDir>
    <DisableImplicitFrameworkReferences>true</DisableImplicitFrameworkReferences>
  </PropertyGroup>
  <Import Project="$(NETStandardLibraryArtifactsDir)build\netstandard2.0\NETStandard.Library.targets" Condition="'$(TargetFramework)' == 'netstandard2.0' and '$(ExcludeRestorePackageImports)' != 'true' and Exists('$(NETStandardLibraryArtifactsDir)')" />

  <PropertyGroup>
    <EnableTargetingPackDownload>false</EnableTargetingPackDownload>
    <GenerateErrorForMissingTargetingPacks>false</GenerateErrorForMissingTargetingPacks>

    <!-- Avoid transitive framework reference downloads to minimize the number of targeting packs and prebuilts. -->
    <DisableTransitiveFrameworkReferenceDownloads>true</DisableTransitiveFrameworkReferenceDownloads>

    <CustomizationsPropsPath>$(MSBuildProjectDirectory)\$(CustomizationsPropsFile)</CustomizationsPropsPath>
    <CustomizationsSourcePath>$(MSBuildProjectDirectory)\$(CustomizationsSourceFile)</CustomizationsSourcePath>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="ref/$(TargetFramework)/*$(DefaultLanguageSourceExtension)" />
    <Compile Include="lib/$(TargetFramework)/*$(DefaultLanguageSourceExtension)" />

    <!-- Attributes for all Reference Packages -->
    <Compile Include="$(RepoRoot)src\SourceBuildAssemblyMetdata.cs" />

    <!-- Customization extension point -->
    <Compile Include="$(CustomizationsSourcePath)" Condition="Exists('$(CustomizationsSourcePath)')" />
  </ItemGroup>

  <!-- Customization extension point -->
  <Import Project="$(CustomizationsPropsPath)" Condition="Exists('$(CustomizationsPropsPath)')" />

  <!--
    ### Targeting Packs section ###
    Keep in sync with available targeting packs under src/targetPacks/ILsrc.
  -->

  <ItemGroup>
    <KnownFrameworkReference Update="@(KnownFrameworkReference->WithMetadataValue('Identity', 'Microsoft.NETCore.App'))">
      <TargetingPackVersion Condition="'%(TargetFramework)' == 'netcoreapp3.0'">3.0.0</TargetingPackVersion>
      <TargetingPackVersion Condition="'%(TargetFramework)' == 'netcoreapp3.1'">3.1.0</TargetingPackVersion>
      <TargetingPackVersion Condition="$([System.Text.RegularExpressions.Regex]::IsMatch('%(TargetFramework)', '^net\d+\.0$'))">$([System.Text.RegularExpressions.Regex]::Match('%(TargetFramework)', '\d+').Value).0.0</TargetingPackVersion>
    </KnownFrameworkReference>

    <KnownFrameworkReference Update="@(KnownFrameworkReference->WithMetadataValue('Identity', 'NETStandard.Library'))">
      <TargetingPackVersion Condition="'%(TargetFramework)' == 'netstandard2.1'">2.1.0</TargetingPackVersion>
    </KnownFrameworkReference>
  </ItemGroup>

  <!-- Conflict resolution doesn't see P2Ps: https://github.com/dotnet/sdk/issues/2674. -->
  <Target Name="PassProjectReferencesToConflictResolution"
          BeforeTargets="_HandlePackageFileConflicts"
          DependsOnTargets="ResolveProjectReferences">
    <ItemGroup>
      <Reference Include="@(_ResolvedProjectReferencePaths)" />
      <_ResolvedProjectReferencePaths Remove="@(_ResolvedProjectReferencePaths)" />
    </ItemGroup>
  </Target>

  <!-- Filter out conflicting implicit assembly references. -->
  <Target Name="FilterImplicitAssemblyReferences"
          DependsOnTargets="ResolveProjectReferences"
          AfterTargets="ResolveTargetingPackAssets">
    <ItemGroup>
      <_targetingPackReferenceExclusion Include="$(TargetName)" />
    </ItemGroup>
    <ItemGroup>
      <_targetingPackReferenceWithProjectName Include="@(Reference->WithMetadataValue('ExternallyResolved', 'true')->Metadata('Filename'))"
                                              OriginalIdentity="%(Identity)" />
      <_targetingPackIncludedReferenceWithProjectName Include="@(_targetingPackReferenceWithProjectName)"
                                                      Exclude="@(_targetingPackReferenceExclusion)" />
      <_targetingPackExcludedReferenceWithProjectName Include="@(_targetingPackReferenceWithProjectName)"
                                                      Exclude="@(_targetingPackIncludedReferenceWithProjectName)" />
      <Reference Remove="@(_targetingPackExcludedReferenceWithProjectName->Metadata('OriginalIdentity'))" />
    </ItemGroup>
  </Target>

  <Target Name="CopyBuildOutputToTempOutput"
          AfterTargets="CopyFilesToOutputDirectory">

    <ItemGroup>
      <CompileWithRelativePath Include="@(Compile)" Condition="!$([System.String]::new('%(Identity)').StartsWith('%(RootDir)'))" />
    </ItemGroup>

    <Error
      Condition="@(CompileWithRelativePath->Count()) != 1"
      Text="Number of Compile items != 1. We need just one, to determine the path of the resulting DLL in the package including ref/lib and TFM." />

    <ItemGroup>
      <FullCompileDir Include="$([System.IO.Directory]::GetParent('%(CompileWithRelativePath.Identity)'))" />
      <RelativeCompileDir Include="$([MSBuild]::MakeRelative('$(MSBuildProjectDirectory)\', '%(FullCompileDir.Identity)'))" />
    </ItemGroup>

    <Copy
      SourceFiles="$(TargetPath)"
      DestinationFiles="$([MSBuild]::NormalizePath(
        '$(TFMPackTempOutputDir)',
        '%(RelativeCompileDir.Identity)',
        '$(TargetFileName)'))" />
  </Target>

  <!-- Use local targeting packs -->
  <Target Name="UseLocalTargetingPack" AfterTargets="ResolveFrameworkReferences">
    <ItemGroup>
      <ResolvedTargetingPack Path="$(ArtifactsBinDir)%(ResolvedTargetingPack.NuGetPackageId).%(ResolvedTargetingPack.NuGetPackageVersion)\pack"
                             PackageDirectory="$(ArtifactsBinDir)%(ResolvedTargetingPack.NuGetPackageId).%(ResolvedTargetingPack.NuGetPackageVersion)\pack" />
      <ResolvedFrameworkReference TargetingPackPath="$(ArtifactsBinDir)%(ResolvedFrameworkReference.TargetingPackName).%(ResolvedFrameworkReference.TargetingPackVersion)\pack" />
    </ItemGroup>
  </Target>

</Project>
