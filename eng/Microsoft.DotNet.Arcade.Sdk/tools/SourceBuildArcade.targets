<Project>

  <!--
    These targets inject source-build into Arcade's build process.
  -->

  <PropertyGroup>
    <SourceBuildOutputDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'source-build'))</SourceBuildOutputDir>
    <SourceBuildSelfDir>$([MSBuild]::NormalizeDirectory('$(SourceBuildOutputDir)', 'self'))</SourceBuildSelfDir>
    <CurrentRepoSourceBuildArtifactsDir>$([MSBuild]::NormalizeDirectory('$(SourceBuildSelfDir)', 'artifacts'))</CurrentRepoSourceBuildArtifactsDir>
    <CurrentRepoSourceBuildSourceDir>$([MSBuild]::NormalizeDirectory('$(SourceBuildSelfDir)', 'src'))</CurrentRepoSourceBuildSourceDir>
    <CurrentRepoSourceBuildPackageCache>$([MSBuild]::NormalizeDirectory('$(SourceBuildSelfDir)', 'package-cache'))</CurrentRepoSourceBuildPackageCache>

    <CurrentRepoSourceBuildArtifactsPackagesDir>$([MSBuild]::NormalizeDirectory('$(CurrentRepoSourceBuildArtifactsDir)', 'packages', '$(Configuration)'))</CurrentRepoSourceBuildArtifactsPackagesDir>
    <CurrentRepoSourceBuildBinlogFile>$([MSBuild]::NormalizePath('$(CurrentRepoSourceBuildArtifactsDir)', 'sourcebuild.binlog'))</CurrentRepoSourceBuildBinlogFile>

    <InnerSourceBuildRepoRoot Condition="'$(InnerSourceBuildRepoRoot)' == ''">$(CurrentRepoSourceBuildSourceDir)</InnerSourceBuildRepoRoot>

    <CleanInnerSourceBuildRepoRoot Condition="'$(CleanInnerSourceBuildRepoRoot)' == ''">true</CleanInnerSourceBuildRepoRoot>
  </PropertyGroup>

  <Target Name="BuildSourceBuildTasks"
          Condition="
            '$(FromSource)' == 'true' and
            '$(InnerBuildFromSource)' == 'true'"
          BeforeTargets="Execute">
    <ItemGroup>
      <BuildTargets Include="Restore;Build" />
    </ItemGroup>

    <MSBuild
      Projects="$(MSBuildThisFileDirectory)..\tasks\source-build-tasks.csproj"
      Targets="%(BuildTargets.Identity)"
      Properties="__ToolInitPhase=%(BuildTargets.Identity)"/>
  </Target>

  <Target Name="BuildUpstreamRepos"
          Condition="
            '$(FromSource)' == 'true' and
            '$(InnerBuildFromSource)' != 'true' and
            '$(BuildUpstreamRepos)' == 'true'">
    <!-- TODO: Clone upstream repos and build them. -->
    <Error Text="NotImplemented" />
  </Target>

  <!--
    Set up build args to append to the passed build command. These args specify what is unique about
    building from source, such as non-overlapping artifacts dirs and package caches. This target can
    be BeforeTargets'd or replaced to customize source-build.
  -->
  <Target Name="GetSourceBuildCommandConfiguration">
    <PropertyGroup>
      <!-- Track that this is the inner build to prevent infinite recursion. -->
      <InnerBuildArgs>$(InnerBuildArgs) /p:InnerBuildFromSource=true</InnerBuildArgs>
      <!-- Set DotNetBuildFromSource to avoid publishing. -->
      <InnerBuildArgs>$(InnerBuildArgs) /p:DotNetBuildFromSource=true</InnerBuildArgs>
      <!-- Use a fresh clone of the repo so that source-build modifications are isolated. -->
      <InnerBuildArgs>$(InnerBuildArgs) /p:RepoRoot=$(InnerSourceBuildRepoRoot)</InnerBuildArgs>
      <!-- Override the artifacts dir to cleanly separate the inner build from outer build. -->
      <InnerBuildArgs>$(InnerBuildArgs) /p:ArtifactsDir=$(CurrentRepoSourceBuildArtifactsDir)</InnerBuildArgs>
      <!-- Set a custom binlog location to avoid clashing over the currenly specified file. -->
      <InnerBuildArgs>$(InnerBuildArgs) /bl:$(CurrentRepoSourceBuildBinlogFile)</InnerBuildArgs>

      <!-- Work around issue where local clone may cause failure using non-origin remote fallback: https://github.com/dotnet/sourcelink/issues/629 -->
      <InnerBuildArgs>$(InnerBuildArgs) /p:EnableSourceControlManagerQueries=false</InnerBuildArgs>
      <InnerBuildArgs>$(InnerBuildArgs) /p:EnableSourceLink=false</InnerBuildArgs>
    </PropertyGroup>

    <ItemGroup>
      <!-- Override package cache to separate source-built packages from upstream. -->
      <InnerBuildEnv Include="NUGET_PACKAGES=$(CurrentRepoSourceBuildPackageCache)" />
    </ItemGroup>
  </Target>

  <Target Name="CleanInnerSourceBuildRepoRoot"
          Condition="'$(CleanInnerSourceBuildRepoRoot)' == 'true'">
    <RemoveDir Directories="$(InnerSourceBuildRepoRoot)" />
  </Target>

  <!--
    Clone the repo to a new location. Source-build targets will change the source dynamically.
    Creating a fresh clone avoids overwriting existing work or making subtle changes that might
    accidentally get added to the user's existing work via a 'git add .'. Since the clone also has
    access to the git data, this also makes it easy to see what changes the source-build infra has
    made, for diagnosis or exploratory purposes.
  -->
  <Target Name="PrepareInnerSourceBuildRepoRoot"
          DependsOnTargets="CleanInnerSourceBuildRepoRoot">
    <Exec
      Command="
        set -xeuo pipefail
        # Copy over changes that haven't been committed, for dev inner loop.
        stashCommit=%24(git stash create)
        git clone --no-checkout . &quot;$(InnerSourceBuildRepoRoot)&quot;
        cd &quot;$(InnerSourceBuildRepoRoot)&quot;
        # If no changes were stashed, stashCommit is empty, and this becomes simple checkout.
        git checkout %24stashCommit"
      WorkingDirectory="$(RepoRoot)" />

    <!--
      An alternative to "git clone" would be to use a "git worktree". Potential benefits:
      * This has more integration with the user's normal repo. If they make ad-hoc changes in the
        worktree, it is easy to cherry-pick onto the developer's "real" branch.
      * A worktree uses a '.git' file rather than a full '.git' directory, which might have storage
        implications. (However, a local clone's '.git' directory uses hard links to save space/time,
        so it's not certain that this affects performance at all.)

      Downside of worktrees:
      * Some configuration is set up in '.git/worktrees' which may be difficult to coordinate
        properly. In particular, if the user is already using worktrees for their own purposes, we
        would have to be careful that running source-build in one worktree doesn't interfere with
        source-build in the other worktree.
    -->
  </Target>

  <Target Name="ExecuteWithSourceBuiltTooling"
          DependsOnTargets="
            BuildUpstreamRepos;
            GetSourceBuildCommandConfiguration;
            ExecuteInnerSourceBuild;
            PackSourceBuildIntermediateNupkg"
          Condition="
            '$(FromSource)' == 'true' and
            '$(InnerBuildFromSource)' != 'true'"
          BeforeTargets="Execute" />

  <!--
    Separate target to execute to provide easy hook point for BeforeTargets that will only trigger
    when the inner build is actually happening. Hooking BeforeTargets on
    ExecuteWithSourceBuiltTooling would run unconditionally.
  -->
  <Target Name="ExecuteInnerSourceBuild"
          DependsOnTargets="PrepareInnerSourceBuildRepoRoot">
    <PropertyGroup>
      <!-- Prevent any projects from building in the outside build: they would use prebuilts. -->
      <PreventPrebuiltBuild>true</PreventPrebuiltBuild>

      <!--
        Normally, the inner build should run using the original build command with some extra args
        appended. Allow the repo to override this default behavior if the repo is e.g. not onboarded
        enough on Arcade for this to work nicely.
      -->
      <BaseInnerSourceBuildCommand Condition="'$(BaseInnerSourceBuildCommand)' == ''">$(ARCADE_BUILD_TOOL_COMMAND)</BaseInnerSourceBuildCommand>
    </PropertyGroup>

    <Exec
      Command="$(BaseInnerSourceBuildCommand) $(InnerBuildArgs)"
      WorkingDirectory="$(InnerSourceBuildRepoRoot)"
      EnvironmentVariables="@(InnerBuildEnv)"
      IgnoreStandardErrorWarningFormat="true" />
  </Target>

  <!--
    Create a source-build intermediate NuGet package for dependency transport.
  -->
  <Target Name="PackSourceBuildIntermediateNupkg">
    <PropertyGroup>
      <SourceBuildIntermediateProjFile>$(MSBuildThisFileDirectory)SourceBuildIntermediate.proj</SourceBuildIntermediateProjFile>
      <SourceBuildIntermediateProjTargetFile>$(ArtifactsObjDir)ArcadeGeneratedProjects\SourceBuildIntermediate\SourceBuildIntermediate.proj</SourceBuildIntermediateProjTargetFile>
    </PropertyGroup>

    <!-- Copy the project to artifacts/ so that the repo's global.json is in an ancestor dir. -->
    <Copy
      SourceFiles="$(SourceBuildIntermediateProjFile)"
      DestinationFiles="$(SourceBuildIntermediateProjTargetFile)" />

    <ItemGroup>
      <SourceBuildIntermediatePackTarget Include="Restore;Pack" />
    </ItemGroup>

    <MSBuild
      Projects="$(SourceBuildIntermediateProjTargetFile)"
      Targets="%(SourceBuildIntermediatePackTarget.Identity)"
      Properties="CurrentRepoSourceBuildArtifactsPackagesDir=$(CurrentRepoSourceBuildArtifactsPackagesDir)" />
  </Target>

  <Target Name="PreventPrebuiltBuild"
          DependsOnTargets="ExecuteWithSourceBuiltTooling"
          Condition="'$(PreventPrebuiltBuild)' == 'true'"
          BeforeTargets="Execute">
    <ItemGroup>
      <ProjectToBuild Remove="@(ProjectToBuild)" />
      <ProjectToBuild Include="$(MSBuildThisFileDirectory)Noop.proj" />
    </ItemGroup>
  </Target>

  <!-- Repository extension point -->
  <Import Project="$(RepositoryEngineeringDir)SourceBuild.props" Condition="Exists('$(RepositoryEngineeringDir)SourceBuild.props')" />

</Project>
