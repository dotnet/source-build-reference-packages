parameters:
  job: null
  pool:
    name: DotNetCore-Linux
  imageName: null

jobs:
- job: ${{ parameters.job }}
  pool: ${{ parameters.pool }}
  timeoutInMinutes: 30
  variables:
    # Use ":z" to set selinux flag for sharing in build-owned root dir. https://docs.docker.com/storage/bind-mounts/#configure-the-selinux-label
    docker.agentSrc.map: -v $(Build.SourcesDirectory):/agentSrc:z
    docker.agentSrc.work: -w /agentSrc
    docker.run: docker run --rm
    docker.root.map: -v $(rootDirectory):/root:z
    docker.src.map: -v $(rootDirectory)/source-build-reference-packages/src:/src:z
    docker.src.work: -w /src
    docker.staging.map: -v $(stagingDirectory):/staging:z
    imageName: ${{ parameters.imageName }}
    rootDirectory: $(Build.SourcesDirectory)/..
    stagingDirectory: $(rootDirectory)/source-build-reference-packages/staging

  steps:
  - template: ../steps/docker-cleanup-linux.yml

  # Create working directory and copy source into it.
  - script: |
      set -x
      df -h
      $(docker.run) $(docker.root.map) $(docker.agentSrc.map) $(docker.agentSrc.work) $(imageName) bash -c '
        mkdir -p /root/source-build-reference-packages/staging
        rm -rf /root/source-build-reference-packages/src
        mkdir -p /root/source-build-reference-packages/src
        cp -r . /root/source-build-reference-packages/src'
    displayName: Clean source-build-reference-packages directory and copy source from cloned directory

  # Build reference packages
  - script: |
      set -x
      df -h
      $(docker.run) $(docker.src.map) $(docker.src.work) $(imageName) ./build.sh
    displayName: Build reference packages
    timeoutInMinutes: 30

  # Create reference packages tarball
  - script: |
      set -x
      df -h
      $(docker.run) $(docker.src.map) $(docker.src.work) $(imageName) ./publish.sh $(BUILD.BUILDNUMBER) --ci
    displayName: Create reference packages tarball
    condition: "
        and(
            succeeded(),
            eq(variables['System.TeamProject'], 'public'),
            in(variables['Build.Reason'], 'PullRequest')
        )"
    continueOnError: true

  # Create reference packages tarball and upload to azure storage
  - script: |
      set -x
      df -h
      $(docker.run) $(docker.src.map) $(docker.src.work) $(imageName) ./publish.sh $(BUILD.BUILDNUMBER) --ci \
        /p:AzureAccountName=$(publish.blobStorage.account) \
        /p:ContainerName=$(publish.blobStorage.container) \
        /p:AzureAccessToken=$(publish.blobStorage.accessToken) \
        /p:ManifestName=$(BUILD.REPOSITORY.NAME) \
        /p:ManifestBuildId=$(BUILD.BUILDID) \
        /p:ManifestBranch=$(BUILD.SOURCEBRANCHNAME) \
        /p:ManifestCommit=$(BUILD.SOURCEVERSION)
    displayName: Create reference packages tarball and upload to azure storage
    condition: "
        and(
            succeeded(),
            ne(variables['System.TeamProject'], 'public'),
            notin(variables['Build.Reason'], 'PullRequest')
        )"
    continueOnError: true

  # Copy artifacts and logs to staging directory.
  - script: |
      set -x
      df -h
      $(docker.run) $(docker.staging.map) $(docker.src.map) $(docker.src.work) $(imageName) /bin/bash -c "
        mkdir /staging/logs

        find . -iname '*.binlog' \
          -exec cp {} --parents /staging/logs \;

        if [ -d ./artifacts/asset-manifests ]; then
            cp -r ./artifacts/asset-manifests /staging/
        fi
        if [ -d ./artifacts/tarball ]; then
            cp -r ./artifacts/tarball /staging/
        fi"
    displayName: Copy build logs and artifacts
    condition: always()
    continueOnError: true

  # Copy artifacts to staging - Copy to VSTS owned folder is done outside of docker so copied files
  # have correct ownership so VSTS can clean them up later.
  - task: CopyFiles@2
    condition: always()
    continueOnError: true
    inputs:
      sourceFolder: $(stagingDirectory)
      targetFolder: $(Build.ArtifactStagingDirectory)

  # Publish artifacts.
  - task: PublishBuildArtifacts@1
    displayName: Publish Artifacts
    condition: always()
    continueOnError: true
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)
      ArtifactName: Artifacts
      ArtifactType: Container

  # Publish manifest.
  - task: PublishBuildArtifacts@1
    displayName: Publish Manifest
    condition: "
        and(
            succeeded(),
            ne(variables['System.TeamProject'], 'public'),
            notin(variables['Build.Reason'], 'PullRequest')
        )"
    continueOnError: true
    inputs:
      PathtoPublish: $(Build.ArtifactStagingDirectory)/asset-manifests/
      ArtifactName: AssetManifests
      ArtifactType: Container

  # Clean up working directory.
  - script: $(docker.run) $(docker.root.map) $(imageName) bash -c 'rm -rf /root/source-build-reference-packages'
    displayName: Clean working directory
    condition: always()
    continueOnError: true

  - template: ../steps/docker-cleanup-linux.yml
